# -*- coding: utf-8 -*-
"""Generate C code for trace data capture."""

from pathlib import Path
from typing import Optional
from .format import TraceFormat, DTYPE_MAP, DType


def generate_trace_code(
    onnx_path: str,
    output_dir: str = ".",
    prefix: str = "trace",
) -> dict:
    """
    Generate C header and source for trace capture.

    Args:
        onnx_path: Path to ONNX model
        output_dir: Output directory
        prefix: File prefix (default: "trace")

    Returns:
        dict with paths to generated files

    Usage:
        files = generate_trace_code("model.onnx", output_dir="./generated")
        # Creates:
        #   ./generated/trace_format.h   - Format definitions
        #   ./generated/trace_tensors.h  - Tensor declarations
        #   ./generated/trace_init.c     - Init function
    """
    trace_format = TraceFormat.from_onnx(onnx_path)
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    files = {}

    # Generate format header
    format_h = _generate_format_header(prefix)
    format_path = output_dir / f"{prefix}_format.h"
    format_path.write_text(format_h)
    files["format_h"] = str(format_path)

    # Generate tensor declarations
    tensors_h = _generate_tensors_header(trace_format, prefix)
    tensors_path = output_dir / f"{prefix}_tensors.h"
    tensors_path.write_text(tensors_h)
    files["tensors_h"] = str(tensors_path)

    # Generate init code
    init_c = _generate_init_code(trace_format, prefix)
    init_path = output_dir / f"{prefix}_init.c"
    init_path.write_text(init_c)
    files["init_c"] = str(init_path)

    # Generate capture helpers
    capture_h = _generate_capture_header(trace_format, prefix)
    capture_path = output_dir / f"{prefix}_capture.h"
    capture_path.write_text(capture_h)
    files["capture_h"] = str(capture_path)

    print(f"Generated {len(files)} files in {output_dir}")
    for name, path in files.items():
        print(f"  {path}")

    return files


def _generate_format_header(prefix: str) -> str:
    """Generate trace_format.h with struct definitions."""
    return f'''\
/**
 * Trace Format Definitions
 * Auto-generated by onnxparser
 */

#ifndef {prefix.upper()}_FORMAT_H
#define {prefix.upper()}_FORMAT_H

#include <stdint.h>

#define TRACE_MAGIC 0x43525458  /* "XTRC" */
#define TRACE_VERSION 1

/* Standard data types */
typedef enum {{
    DTYPE_FLOAT32 = 0,
    DTYPE_FLOAT16 = 1,
    DTYPE_BFLOAT16 = 2,
    DTYPE_INT32 = 3,
    DTYPE_INT64 = 4,
    DTYPE_INT8 = 5,
    DTYPE_UINT8 = 6,
    DTYPE_INT4 = 7,
    DTYPE_UINT4 = 8,
}} trace_dtype_t;

/* Hardware-specific data types */
typedef enum {{
    HW_DTYPE_NONE = 0,        /* No conversion needed */
    HW_DTYPE_FP8_E4M3 = 10,   /* FP8 E4M3 format */
    HW_DTYPE_FP8_E5M2 = 11,   /* FP8 E5M2 format */
    HW_DTYPE_BFP8 = 20,       /* Block FP, 8-bit mantissa */
    HW_DTYPE_BFP12 = 21,      /* Block FP, 12-bit mantissa */
    HW_DTYPE_BFP16 = 22,      /* Block FP, 16-bit mantissa */
    HW_DTYPE_FXP8 = 30,       /* Fixed point 8-bit */
    HW_DTYPE_FXP16 = 31,      /* Fixed point 16-bit */
    HW_DTYPE_FXP32 = 32,      /* Fixed point 32-bit */
}} trace_hw_dtype_t;

/* File header: 64 bytes */
typedef struct __attribute__((packed)) {{
    uint32_t magic;       /* TRACE_MAGIC */
    uint16_t version;     /* TRACE_VERSION */
    uint16_t flags;       /* Reserved */
    uint32_t num_tensors; /* Number of tensors */
    uint8_t reserved[52]; /* Padding to 64 bytes */
}} trace_file_header_t;

/* Tensor header: 128 bytes */
typedef struct __attribute__((packed)) {{
    char name[48];        /* Tensor name (null-terminated) */
    uint8_t dtype;        /* Standard data type */
    uint8_t hw_dtype;     /* Hardware-specific data type */
    uint8_t ndim;         /* Number of dimensions */
    uint8_t valid;        /* 1 if captured, 0 otherwise */
    uint8_t is_input;     /* 1 if model input */
    uint8_t has_exponent; /* 1 if BFP with separate exponent */
    uint16_t block_size;  /* BFP block size (0 if not BFP) */
    uint32_t shape[8];    /* Shape (up to 8 dims) */
    uint64_t data_size;   /* Mantissa/data size in bytes */
    uint64_t exp_size;    /* Exponent size in bytes (0 if not BFP) */
    uint64_t exp_offset;  /* Exponent offset relative to data start */
    uint8_t reserved[16]; /* Padding to 128 bytes */
}} trace_tensor_header_t;

/* Verify struct sizes at compile time */
_Static_assert(sizeof(trace_file_header_t) == 64, "file header size mismatch");
_Static_assert(sizeof(trace_tensor_header_t) == 128, "tensor header size mismatch");

#endif /* {prefix.upper()}_FORMAT_H */
'''


def _generate_tensors_header(trace_format: TraceFormat, prefix: str) -> str:
    """Generate trace_tensors.h with tensor index definitions."""
    lines = [f'''\
/**
 * Tensor Index Definitions
 * Auto-generated by onnxparser
 */

#ifndef {prefix.upper()}_TENSORS_H
#define {prefix.upper()}_TENSORS_H

#define TRACE_NUM_TENSORS {len(trace_format.tensors)}

/* Tensor indices */
''']

    for i, tensor in enumerate(trace_format.tensors):
        # Convert name to valid C identifier
        c_name = _to_c_identifier(tensor.name)
        lines.append(f"#define TENSOR_{c_name} {i}")

    lines.append(f'''
/* Tensor names (for lookup) */
static const char* TENSOR_NAMES[TRACE_NUM_TENSORS] = {{
''')

    for tensor in trace_format.tensors:
        lines.append(f'    "{tensor.name}",')

    lines.append(f'''}};

#endif /* {prefix.upper()}_TENSORS_H */
''')

    return "\n".join(lines)


def _generate_init_code(trace_format: TraceFormat, prefix: str) -> str:
    """Generate trace_init.c with initialization function."""
    lines = [f'''\
/**
 * Trace Initialization
 * Auto-generated by onnxparser
 */

#include "{prefix}_format.h"
#include "{prefix}_tensors.h"
#include <string.h>

/* Global trace buffer pointer */
static uint8_t* g_trace_buffer = NULL;
static size_t g_trace_buffer_size = 0;

/* Calculate total buffer size needed */
size_t {prefix}_calc_buffer_size(void) {{
    size_t size = sizeof(trace_file_header_t);
    size += TRACE_NUM_TENSORS * sizeof(trace_tensor_header_t);
''']

    # Add data sizes
    total_data = sum(t.data_size for t in trace_format.tensors)
    lines.append(f"    size += {total_data}UL;  /* Total tensor data */")
    lines.append(f"    return size;")
    lines.append(f"}}")

    lines.append(f'''
/* Initialize trace buffer in DDR */
int {prefix}_init(uint8_t* buffer, size_t buffer_size) {{
    size_t required = {prefix}_calc_buffer_size();
    if (buffer_size < required) {{
        return -1;  /* Buffer too small */
    }}

    g_trace_buffer = buffer;
    g_trace_buffer_size = buffer_size;

    /* Initialize file header */
    trace_file_header_t* file_hdr = (trace_file_header_t*)buffer;
    memset(file_hdr, 0, sizeof(trace_file_header_t));
    file_hdr->magic = TRACE_MAGIC;
    file_hdr->version = TRACE_VERSION;
    file_hdr->num_tensors = TRACE_NUM_TENSORS;

    /* Initialize tensor headers */
    trace_tensor_header_t* tensor_hdrs = (trace_tensor_header_t*)(buffer + sizeof(trace_file_header_t));
''')

    # Generate tensor header initialization
    for i, tensor in enumerate(trace_format.tensors):
        dtype_info = DTYPE_MAP.get(tensor.dtype, ("float32", "float", 4))
        c_type = dtype_info[1]

        lines.append(f'''
    /* Tensor {i}: {tensor.name} */
    memset(&tensor_hdrs[{i}], 0, sizeof(trace_tensor_header_t));
    strncpy(tensor_hdrs[{i}].name, "{tensor.name}", 47);
    tensor_hdrs[{i}].dtype = {tensor.dtype};
    tensor_hdrs[{i}].ndim = {tensor.ndim};
    tensor_hdrs[{i}].valid = 0;
    tensor_hdrs[{i}].is_input = {tensor.is_input};''')

        for j, dim in enumerate(tensor.shape):
            lines.append(f"    tensor_hdrs[{i}].shape[{j}] = {dim};")

        lines.append(f"    tensor_hdrs[{i}].data_size = {tensor.data_size}UL;")

    lines.append(f'''
    return 0;  /* Success */
}}

/* Get pointer to tensor data region */
void* {prefix}_get_tensor_ptr(int tensor_idx) {{
    if (g_trace_buffer == NULL || tensor_idx < 0 || tensor_idx >= TRACE_NUM_TENSORS) {{
        return NULL;
    }}

    size_t offset = sizeof(trace_file_header_t);
    offset += TRACE_NUM_TENSORS * sizeof(trace_tensor_header_t);

    trace_tensor_header_t* tensor_hdrs = (trace_tensor_header_t*)(g_trace_buffer + sizeof(trace_file_header_t));
    for (int i = 0; i < tensor_idx; i++) {{
        offset += tensor_hdrs[i].data_size;
    }}

    return g_trace_buffer + offset;
}}

/* Mark tensor as captured */
void {prefix}_mark_valid(int tensor_idx) {{
    if (g_trace_buffer == NULL || tensor_idx < 0 || tensor_idx >= TRACE_NUM_TENSORS) {{
        return;
    }}

    trace_tensor_header_t* tensor_hdrs = (trace_tensor_header_t*)(g_trace_buffer + sizeof(trace_file_header_t));
    tensor_hdrs[tensor_idx].valid = 1;
}}

/* Get trace buffer for dumping */
uint8_t* {prefix}_get_buffer(size_t* size) {{
    if (size) {{
        *size = g_trace_buffer_size;
    }}
    return g_trace_buffer;
}}
''')

    return "\n".join(lines)


def _generate_capture_header(trace_format: TraceFormat, prefix: str) -> str:
    """Generate trace_capture.h with capture macros."""
    lines = [f'''\
/**
 * Trace Capture Helpers
 * Auto-generated by onnxparser
 */

#ifndef {prefix.upper()}_CAPTURE_H
#define {prefix.upper()}_CAPTURE_H

#include "{prefix}_format.h"
#include "{prefix}_tensors.h"
#include <string.h>

/* Function declarations */
void* {prefix}_get_tensor_ptr(int tensor_idx);
void {prefix}_mark_valid(int tensor_idx);

/* Capture tensor data */
#define TRACE_CAPTURE(tensor_idx, src_ptr) do {{ \\
    void* dst = {prefix}_get_tensor_ptr(tensor_idx); \\
    if (dst && src_ptr) {{ \\
        trace_tensor_header_t* hdrs = (trace_tensor_header_t*)(g_trace_buffer + sizeof(trace_file_header_t)); \\
        memcpy(dst, src_ptr, hdrs[tensor_idx].data_size); \\
        {prefix}_mark_valid(tensor_idx); \\
    }} \\
}} while(0)

/* Capture with DMA (placeholder - implement based on your hardware) */
#define TRACE_CAPTURE_DMA(tensor_idx, src_addr) do {{ \\
    void* dst = {prefix}_get_tensor_ptr(tensor_idx); \\
    /* TODO: Implement DMA transfer from src_addr to dst */ \\
    {prefix}_mark_valid(tensor_idx); \\
}} while(0)

''']

    # Generate per-tensor capture macros
    lines.append("/* Per-tensor capture macros */")
    for i, tensor in enumerate(trace_format.tensors):
        c_name = _to_c_identifier(tensor.name)
        lines.append(f"#define CAPTURE_{c_name}(src) TRACE_CAPTURE({i}, src)")

    lines.append(f'''
#endif /* {prefix.upper()}_CAPTURE_H */
''')

    return "\n".join(lines)


def _to_c_identifier(name: str) -> str:
    """Convert tensor name to valid C identifier."""
    # Replace invalid characters
    result = name.replace("/", "_").replace(".", "_").replace("-", "_")
    result = result.replace(":", "_").replace(" ", "_")
    # Remove leading underscores
    result = result.lstrip("_")
    # Ensure starts with letter
    if result and result[0].isdigit():
        result = "t_" + result
    return result.upper()
